/* tslint:disable */
/* eslint-disable */
/**
 * AI Stats Gateway API
 * A gateway API for accessing various AI models with OpenAI-compatible endpoints.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import * as runtime from '../runtime';
import type {
  AudioSpeechRequest,
  AudioTranscriptionResponse,
  AudioTranslationResponse,
  BatchRequest,
  BatchResponse,
  ChatCompletionsRequest,
  ChatCompletionsResponse,
  EmbeddingsRequest,
  EmbeddingsResponse,
  FileResponse,
  GenerationResponse,
  GetAnalytics200Response,
  GetAnalyticsRequest,
  GetGeneration401Response,
  GetGeneration404Response,
  Healthz200Response,
  ImagesEditResponse,
  ImagesGenerationRequest,
  ImagesGenerationResponse,
  ListFilesResponse,
  ListModels200Response,
  ListModels500Response,
  ListModelsOrganisationParameter,
  ModerationsRequest,
  ModerationsResponse,
  ResponsesRequest,
  ResponsesResponse,
  Root200Response,
  VideoGenerationRequest,
  VideoGenerationResponse,
} from '../models/index';
import {
    AudioSpeechRequestFromJSON,
    AudioSpeechRequestToJSON,
    AudioTranscriptionResponseFromJSON,
    AudioTranscriptionResponseToJSON,
    AudioTranslationResponseFromJSON,
    AudioTranslationResponseToJSON,
    BatchRequestFromJSON,
    BatchRequestToJSON,
    BatchResponseFromJSON,
    BatchResponseToJSON,
    ChatCompletionsRequestFromJSON,
    ChatCompletionsRequestToJSON,
    ChatCompletionsResponseFromJSON,
    ChatCompletionsResponseToJSON,
    EmbeddingsRequestFromJSON,
    EmbeddingsRequestToJSON,
    EmbeddingsResponseFromJSON,
    EmbeddingsResponseToJSON,
    FileResponseFromJSON,
    FileResponseToJSON,
    GenerationResponseFromJSON,
    GenerationResponseToJSON,
    GetAnalytics200ResponseFromJSON,
    GetAnalytics200ResponseToJSON,
    GetAnalyticsRequestFromJSON,
    GetAnalyticsRequestToJSON,
    GetGeneration401ResponseFromJSON,
    GetGeneration401ResponseToJSON,
    GetGeneration404ResponseFromJSON,
    GetGeneration404ResponseToJSON,
    Healthz200ResponseFromJSON,
    Healthz200ResponseToJSON,
    ImagesEditResponseFromJSON,
    ImagesEditResponseToJSON,
    ImagesGenerationRequestFromJSON,
    ImagesGenerationRequestToJSON,
    ImagesGenerationResponseFromJSON,
    ImagesGenerationResponseToJSON,
    ListFilesResponseFromJSON,
    ListFilesResponseToJSON,
    ListModels200ResponseFromJSON,
    ListModels200ResponseToJSON,
    ListModels500ResponseFromJSON,
    ListModels500ResponseToJSON,
    ListModelsOrganisationParameterFromJSON,
    ListModelsOrganisationParameterToJSON,
    ModerationsRequestFromJSON,
    ModerationsRequestToJSON,
    ModerationsResponseFromJSON,
    ModerationsResponseToJSON,
    ResponsesRequestFromJSON,
    ResponsesRequestToJSON,
    ResponsesResponseFromJSON,
    ResponsesResponseToJSON,
    Root200ResponseFromJSON,
    Root200ResponseToJSON,
    VideoGenerationRequestFromJSON,
    VideoGenerationRequestToJSON,
    VideoGenerationResponseFromJSON,
    VideoGenerationResponseToJSON,
} from '../models/index';

export interface CreateBatchRequest {
    batchRequest: BatchRequest;
}

export interface CreateChatCompletionRequest {
    chatCompletionsRequest: ChatCompletionsRequest;
}

export interface CreateEmbeddingRequest {
    embeddingsRequest: EmbeddingsRequest;
}

export interface CreateImageRequest {
    imagesGenerationRequest: ImagesGenerationRequest;
}

export interface CreateImageEditRequest {
    model: string;
    image: string;
    prompt: string;
    mask?: string;
    size?: string;
    n?: number;
    user?: string;
    meta?: boolean;
    usage?: boolean;
}

export interface CreateModerationRequest {
    moderationsRequest: ModerationsRequest;
}

export interface CreateResponseRequest {
    responsesRequest: ResponsesRequest;
}

export interface CreateSpeechRequest {
    audioSpeechRequest: AudioSpeechRequest;
}

export interface CreateTranscriptionRequest {
    model: string;
    audioUrl?: string;
    audioB64?: string;
    language?: string;
}

export interface CreateTranslationRequest {
    model: string;
    audioUrl?: string;
    audioB64?: string;
    language?: string;
    prompt?: string;
    temperature?: number;
}

export interface CreateVideoRequest {
    videoGenerationRequest: VideoGenerationRequest;
}

export interface GetAnalyticsOperationRequest {
    getAnalyticsRequest: GetAnalyticsRequest;
}

export interface GetGenerationRequest {
    id: string;
}

export interface ListModelsRequest {
    endpoints?: Array<string>;
    organisation?: ListModelsOrganisationParameter;
    inputTypes?: Array<string>;
    outputTypes?: Array<string>;
    params?: Array<string>;
    limit?: number;
    offset?: number;
}

export interface RetrieveBatchRequest {
    batchId: string;
}

export interface RetrieveFileRequest {
    fileId: string;
}

export interface UploadFileRequest {
    file: Blob;
    purpose: string;
}

/**
 * 
 */
export class DefaultApi extends runtime.BaseAPI {

    /**
     * Creates a batch of API requests.
     * Create batch
     */
    async createBatchRaw(requestParameters: CreateBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchResponse>> {
        if (requestParameters['batchRequest'] == null) {
            throw new runtime.RequiredError(
                'batchRequest',
                'Required parameter "batchRequest" was null or undefined when calling createBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/batches`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: BatchRequestToJSON(requestParameters['batchRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchResponseFromJSON(jsonValue));
    }

    /**
     * Creates a batch of API requests.
     * Create batch
     */
    async createBatch(requestParameters: CreateBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchResponse> {
        const response = await this.createBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a completion for the chat message.
     * Create chat completion
     */
    async createChatCompletionRaw(requestParameters: CreateChatCompletionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ChatCompletionsResponse>> {
        if (requestParameters['chatCompletionsRequest'] == null) {
            throw new runtime.RequiredError(
                'chatCompletionsRequest',
                'Required parameter "chatCompletionsRequest" was null or undefined when calling createChatCompletion().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/chat/completions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ChatCompletionsRequestToJSON(requestParameters['chatCompletionsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ChatCompletionsResponseFromJSON(jsonValue));
    }

    /**
     * Creates a completion for the chat message.
     * Create chat completion
     */
    async createChatCompletion(requestParameters: CreateChatCompletionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ChatCompletionsResponse> {
        const response = await this.createChatCompletionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an embedding vector representing the input text.
     * Create embeddings
     */
    async createEmbeddingRaw(requestParameters: CreateEmbeddingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<EmbeddingsResponse>> {
        if (requestParameters['embeddingsRequest'] == null) {
            throw new runtime.RequiredError(
                'embeddingsRequest',
                'Required parameter "embeddingsRequest" was null or undefined when calling createEmbedding().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/embeddings`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: EmbeddingsRequestToJSON(requestParameters['embeddingsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => EmbeddingsResponseFromJSON(jsonValue));
    }

    /**
     * Creates an embedding vector representing the input text.
     * Create embeddings
     */
    async createEmbedding(requestParameters: CreateEmbeddingRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<EmbeddingsResponse> {
        const response = await this.createEmbeddingRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an image given a prompt.
     * Create image
     */
    async createImageRaw(requestParameters: CreateImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagesGenerationResponse>> {
        if (requestParameters['imagesGenerationRequest'] == null) {
            throw new runtime.RequiredError(
                'imagesGenerationRequest',
                'Required parameter "imagesGenerationRequest" was null or undefined when calling createImage().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/images/generations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ImagesGenerationRequestToJSON(requestParameters['imagesGenerationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesGenerationResponseFromJSON(jsonValue));
    }

    /**
     * Creates an image given a prompt.
     * Create image
     */
    async createImage(requestParameters: CreateImageRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagesGenerationResponse> {
        const response = await this.createImageRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates an edited or extended image given an original image and a prompt.
     * Create image edit
     */
    async createImageEditRaw(requestParameters: CreateImageEditRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ImagesEditResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling createImageEdit().'
            );
        }

        if (requestParameters['image'] == null) {
            throw new runtime.RequiredError(
                'image',
                'Required parameter "image" was null or undefined when calling createImageEdit().'
            );
        }

        if (requestParameters['prompt'] == null) {
            throw new runtime.RequiredError(
                'prompt',
                'Required parameter "prompt" was null or undefined when calling createImageEdit().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['image'] != null) {
            formParams.append('image', requestParameters['image'] as any);
        }

        if (requestParameters['mask'] != null) {
            formParams.append('mask', requestParameters['mask'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['size'] != null) {
            formParams.append('size', requestParameters['size'] as any);
        }

        if (requestParameters['n'] != null) {
            formParams.append('n', requestParameters['n'] as any);
        }

        if (requestParameters['user'] != null) {
            formParams.append('user', requestParameters['user'] as any);
        }

        if (requestParameters['meta'] != null) {
            formParams.append('meta', requestParameters['meta'] as any);
        }

        if (requestParameters['usage'] != null) {
            formParams.append('usage', requestParameters['usage'] as any);
        }


        let urlPath = `/images/edits`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ImagesEditResponseFromJSON(jsonValue));
    }

    /**
     * Creates an edited or extended image given an original image and a prompt.
     * Create image edit
     */
    async createImageEdit(requestParameters: CreateImageEditRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ImagesEditResponse> {
        const response = await this.createImageEditRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Classifies if text violates OpenAI\'s usage policies.
     * Create moderation
     */
    async createModerationRaw(requestParameters: CreateModerationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ModerationsResponse>> {
        if (requestParameters['moderationsRequest'] == null) {
            throw new runtime.RequiredError(
                'moderationsRequest',
                'Required parameter "moderationsRequest" was null or undefined when calling createModeration().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/moderations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ModerationsRequestToJSON(requestParameters['moderationsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ModerationsResponseFromJSON(jsonValue));
    }

    /**
     * Classifies if text violates OpenAI\'s usage policies.
     * Create moderation
     */
    async createModeration(requestParameters: CreateModerationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ModerationsResponse> {
        const response = await this.createModerationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a response using the Responses API.
     * Create response
     */
    async createResponseRaw(requestParameters: CreateResponseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ResponsesResponse>> {
        if (requestParameters['responsesRequest'] == null) {
            throw new runtime.RequiredError(
                'responsesRequest',
                'Required parameter "responsesRequest" was null or undefined when calling createResponse().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/responses`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: ResponsesRequestToJSON(requestParameters['responsesRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ResponsesResponseFromJSON(jsonValue));
    }

    /**
     * Creates a response using the Responses API.
     * Create response
     */
    async createResponse(requestParameters: CreateResponseRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ResponsesResponse> {
        const response = await this.createResponseRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Generates audio from the input text.
     * Generate speech
     */
    async createSpeechRaw(requestParameters: CreateSpeechRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Blob>> {
        if (requestParameters['audioSpeechRequest'] == null) {
            throw new runtime.RequiredError(
                'audioSpeechRequest',
                'Required parameter "audioSpeechRequest" was null or undefined when calling createSpeech().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/audio/speech`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: AudioSpeechRequestToJSON(requestParameters['audioSpeechRequest']),
        }, initOverrides);

        return new runtime.BlobApiResponse(response);
    }

    /**
     * Generates audio from the input text.
     * Generate speech
     */
    async createSpeech(requestParameters: CreateSpeechRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Blob> {
        const response = await this.createSpeechRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Transcribes audio into the input language.
     * Create transcription
     */
    async createTranscriptionRaw(requestParameters: CreateTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AudioTranscriptionResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling createTranscription().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['audioUrl'] != null) {
            formParams.append('audio_url', requestParameters['audioUrl'] as any);
        }

        if (requestParameters['audioB64'] != null) {
            formParams.append('audio_b64', requestParameters['audioB64'] as any);
        }

        if (requestParameters['language'] != null) {
            formParams.append('language', requestParameters['language'] as any);
        }


        let urlPath = `/audio/transcriptions`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AudioTranscriptionResponseFromJSON(jsonValue));
    }

    /**
     * Transcribes audio into the input language.
     * Create transcription
     */
    async createTranscription(requestParameters: CreateTranscriptionRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AudioTranscriptionResponse> {
        const response = await this.createTranscriptionRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Translates audio into English.
     * Create translation
     */
    async createTranslationRaw(requestParameters: CreateTranslationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<AudioTranslationResponse>> {
        if (requestParameters['model'] == null) {
            throw new runtime.RequiredError(
                'model',
                'Required parameter "model" was null or undefined when calling createTranslation().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['model'] != null) {
            formParams.append('model', requestParameters['model'] as any);
        }

        if (requestParameters['audioUrl'] != null) {
            formParams.append('audio_url', requestParameters['audioUrl'] as any);
        }

        if (requestParameters['audioB64'] != null) {
            formParams.append('audio_b64', requestParameters['audioB64'] as any);
        }

        if (requestParameters['language'] != null) {
            formParams.append('language', requestParameters['language'] as any);
        }

        if (requestParameters['prompt'] != null) {
            formParams.append('prompt', requestParameters['prompt'] as any);
        }

        if (requestParameters['temperature'] != null) {
            formParams.append('temperature', requestParameters['temperature'] as any);
        }


        let urlPath = `/audio/translations`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => AudioTranslationResponseFromJSON(jsonValue));
    }

    /**
     * Translates audio into English.
     * Create translation
     */
    async createTranslation(requestParameters: CreateTranslationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<AudioTranslationResponse> {
        const response = await this.createTranslationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Creates a video from a prompt.
     * Create video
     */
    async createVideoRaw(requestParameters: CreateVideoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<VideoGenerationResponse>> {
        if (requestParameters['videoGenerationRequest'] == null) {
            throw new runtime.RequiredError(
                'videoGenerationRequest',
                'Required parameter "videoGenerationRequest" was null or undefined when calling createVideo().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/videos`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: VideoGenerationRequestToJSON(requestParameters['videoGenerationRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => VideoGenerationResponseFromJSON(jsonValue));
    }

    /**
     * Creates a video from a prompt.
     * Create video
     */
    async createVideo(requestParameters: CreateVideoRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<VideoGenerationResponse> {
        const response = await this.createVideoRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns aggregated analytics data.
     * Get analytics
     */
    async getAnalyticsRaw(requestParameters: GetAnalyticsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GetAnalytics200Response>> {
        if (requestParameters['getAnalyticsRequest'] == null) {
            throw new runtime.RequiredError(
                'getAnalyticsRequest',
                'Required parameter "getAnalyticsRequest" was null or undefined when calling getAnalytics().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        headerParameters['Content-Type'] = 'application/json';

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/analytics`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: GetAnalyticsRequestToJSON(requestParameters['getAnalyticsRequest']),
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GetAnalytics200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns aggregated analytics data.
     * Get analytics
     */
    async getAnalytics(requestParameters: GetAnalyticsOperationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GetAnalytics200Response> {
        const response = await this.getAnalyticsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieve a specific generation by ID.
     * Get generation
     */
    async getGenerationRaw(requestParameters: GetGenerationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<GenerationResponse>> {
        if (requestParameters['id'] == null) {
            throw new runtime.RequiredError(
                'id',
                'Required parameter "id" was null or undefined when calling getGeneration().'
            );
        }

        const queryParameters: any = {};

        if (requestParameters['id'] != null) {
            queryParameters['id'] = requestParameters['id'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/generation`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => GenerationResponseFromJSON(jsonValue));
    }

    /**
     * Retrieve a specific generation by ID.
     * Get generation
     */
    async getGeneration(requestParameters: GetGenerationRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<GenerationResponse> {
        const response = await this.getGenerationRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns the health status of the API.
     * Health check
     */
    async healthzRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Healthz200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/healthz`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Healthz200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns the health status of the API.
     * Health check
     */
    async healthz(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Healthz200Response> {
        const response = await this.healthzRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of files that belong to the user\'s organization.
     * List files
     */
    async listFilesRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListFilesResponse>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/files`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListFilesResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of files that belong to the user\'s organization.
     * List files
     */
    async listFiles(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListFilesResponse> {
        const response = await this.listFilesRaw(initOverrides);
        return await response.value();
    }

    /**
     * Returns a list of available models.
     * List models
     */
    async listModelsRaw(requestParameters: ListModelsRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<ListModels200Response>> {
        const queryParameters: any = {};

        if (requestParameters['endpoints'] != null) {
            queryParameters['endpoints'] = requestParameters['endpoints'];
        }

        if (requestParameters['organisation'] != null) {
            queryParameters['organisation'] = requestParameters['organisation'];
        }

        if (requestParameters['inputTypes'] != null) {
            queryParameters['input_types'] = requestParameters['inputTypes'];
        }

        if (requestParameters['outputTypes'] != null) {
            queryParameters['output_types'] = requestParameters['outputTypes'];
        }

        if (requestParameters['params'] != null) {
            queryParameters['params'] = requestParameters['params'];
        }

        if (requestParameters['limit'] != null) {
            queryParameters['limit'] = requestParameters['limit'];
        }

        if (requestParameters['offset'] != null) {
            queryParameters['offset'] = requestParameters['offset'];
        }

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/models`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => ListModels200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a list of available models.
     * List models
     */
    async listModels(requestParameters: ListModelsRequest = {}, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<ListModels200Response> {
        const response = await this.listModelsRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Retrieves a batch.
     * Retrieve batch
     */
    async retrieveBatchRaw(requestParameters: RetrieveBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<BatchResponse>> {
        if (requestParameters['batchId'] == null) {
            throw new runtime.RequiredError(
                'batchId',
                'Required parameter "batchId" was null or undefined when calling retrieveBatch().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/batches/{batch_id}`;
        urlPath = urlPath.replace(`{${"batch_id"}}`, encodeURIComponent(String(requestParameters['batchId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => BatchResponseFromJSON(jsonValue));
    }

    /**
     * Retrieves a batch.
     * Retrieve batch
     */
    async retrieveBatch(requestParameters: RetrieveBatchRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<BatchResponse> {
        const response = await this.retrieveBatchRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns information about a specific file.
     * Retrieve file
     */
    async retrieveFileRaw(requestParameters: RetrieveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileResponse>> {
        if (requestParameters['fileId'] == null) {
            throw new runtime.RequiredError(
                'fileId',
                'Required parameter "fileId" was null or undefined when calling retrieveFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/files/{file_id}`;
        urlPath = urlPath.replace(`{${"file_id"}}`, encodeURIComponent(String(requestParameters['fileId'])));

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileResponseFromJSON(jsonValue));
    }

    /**
     * Returns information about a specific file.
     * Retrieve file
     */
    async retrieveFile(requestParameters: RetrieveFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileResponse> {
        const response = await this.retrieveFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

    /**
     * Returns a welcome message.
     * Root endpoint
     */
    async rootRaw(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<Root200Response>> {
        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }

        let urlPath = `/`;

        const response = await this.request({
            path: urlPath,
            method: 'GET',
            headers: headerParameters,
            query: queryParameters,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => Root200ResponseFromJSON(jsonValue));
    }

    /**
     * Returns a welcome message.
     * Root endpoint
     */
    async root(initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<Root200Response> {
        const response = await this.rootRaw(initOverrides);
        return await response.value();
    }

    /**
     * Upload a file that can be used across various endpoints.
     * Upload file
     */
    async uploadFileRaw(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<runtime.ApiResponse<FileResponse>> {
        if (requestParameters['file'] == null) {
            throw new runtime.RequiredError(
                'file',
                'Required parameter "file" was null or undefined when calling uploadFile().'
            );
        }

        if (requestParameters['purpose'] == null) {
            throw new runtime.RequiredError(
                'purpose',
                'Required parameter "purpose" was null or undefined when calling uploadFile().'
            );
        }

        const queryParameters: any = {};

        const headerParameters: runtime.HTTPHeaders = {};

        if (this.configuration && this.configuration.accessToken) {
            const token = this.configuration.accessToken;
            const tokenString = await token("BearerAuth", []);

            if (tokenString) {
                headerParameters["Authorization"] = `Bearer ${tokenString}`;
            }
        }
        const consumes: runtime.Consume[] = [
            { contentType: 'multipart/form-data' },
        ];
        // @ts-ignore: canConsumeForm may be unused
        const canConsumeForm = runtime.canConsumeForm(consumes);

        let formParams: { append(param: string, value: any): any };
        let useForm = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        useForm = canConsumeForm;
        if (useForm) {
            formParams = new FormData();
        } else {
            formParams = new URLSearchParams();
        }

        if (requestParameters['file'] != null) {
            formParams.append('file', requestParameters['file'] as any);
        }

        if (requestParameters['purpose'] != null) {
            formParams.append('purpose', requestParameters['purpose'] as any);
        }


        let urlPath = `/files`;

        const response = await this.request({
            path: urlPath,
            method: 'POST',
            headers: headerParameters,
            query: queryParameters,
            body: formParams,
        }, initOverrides);

        return new runtime.JSONApiResponse(response, (jsonValue) => FileResponseFromJSON(jsonValue));
    }

    /**
     * Upload a file that can be used across various endpoints.
     * Upload file
     */
    async uploadFile(requestParameters: UploadFileRequest, initOverrides?: RequestInit | runtime.InitOverrideFunction): Promise<FileResponse> {
        const response = await this.uploadFileRaw(requestParameters, initOverrides);
        return await response.value();
    }

}
