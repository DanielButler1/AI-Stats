<?php
/**
 * DefaultApi
 * PHP version 8.1
 *
 * @category Class
 * @package  AIStats\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */

/**
 * AI Stats Gateway API
 *
 * A gateway API for accessing various AI models with OpenAI-compatible endpoints.
 *
 * The version of the OpenAPI document: 1.0.0
 * Generated by: https://openapi-generator.tech
 * Generator version: 7.17.0
 */

/**
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

namespace AIStats\Sdk\Api;

use GuzzleHttp\Client;
use GuzzleHttp\ClientInterface;
use GuzzleHttp\Exception\ConnectException;
use GuzzleHttp\Exception\RequestException;
use GuzzleHttp\Psr7\MultipartStream;
use GuzzleHttp\Psr7\Request;
use GuzzleHttp\RequestOptions;
use Psr\Http\Message\RequestInterface;
use Psr\Http\Message\ResponseInterface;
use AIStats\Sdk\ApiException;
use AIStats\Sdk\Configuration;
use AIStats\Sdk\FormDataProcessor;
use AIStats\Sdk\HeaderSelector;
use AIStats\Sdk\ObjectSerializer;

/**
 * DefaultApi Class Doc Comment
 *
 * @category Class
 * @package  AIStats\Sdk
 * @author   OpenAPI Generator team
 * @link     https://openapi-generator.tech
 */
class DefaultApi
{
    /**
     * @var ClientInterface
     */
    protected $client;

    /**
     * @var Configuration
     */
    protected $config;

    /**
     * @var HeaderSelector
     */
    protected $headerSelector;

    /**
     * @var int Host index
     */
    protected $hostIndex;

    /** @var string[] $contentTypes **/
    public const contentTypes = [
        'createBatch' => [
            'application/json',
        ],
        'createChatCompletion' => [
            'application/json',
        ],
        'createEmbedding' => [
            'application/json',
        ],
        'createImage' => [
            'application/json',
        ],
        'createImageEdit' => [
            'multipart/form-data',
        ],
        'createModeration' => [
            'application/json',
        ],
        'createResponse' => [
            'application/json',
        ],
        'createSpeech' => [
            'application/json',
        ],
        'createTranscription' => [
            'multipart/form-data',
        ],
        'createTranslation' => [
            'multipart/form-data',
        ],
        'createVideo' => [
            'application/json',
        ],
        'getAnalytics' => [
            'application/json',
        ],
        'getGeneration' => [
            'application/json',
        ],
        'healthz' => [
            'application/json',
        ],
        'listFiles' => [
            'application/json',
        ],
        'listModels' => [
            'application/json',
        ],
        'retrieveBatch' => [
            'application/json',
        ],
        'retrieveFile' => [
            'application/json',
        ],
        'root' => [
            'application/json',
        ],
        'uploadFile' => [
            'multipart/form-data',
        ],
    ];

    /**
     * @param ClientInterface $client
     * @param Configuration   $config
     * @param HeaderSelector  $selector
     * @param int             $hostIndex (Optional) host index to select the list of hosts if defined in the OpenAPI spec
     */
    public function __construct(
        ?ClientInterface $client = null,
        ?Configuration $config = null,
        ?HeaderSelector $selector = null,
        int $hostIndex = 0
    ) {
        $this->client = $client ?: new Client();
        $this->config = $config ?: Configuration::getDefaultConfiguration();
        $this->headerSelector = $selector ?: new HeaderSelector();
        $this->hostIndex = $hostIndex;
    }

    /**
     * Set the host index
     *
     * @param int $hostIndex Host index (required)
     */
    public function setHostIndex($hostIndex): void
    {
        $this->hostIndex = $hostIndex;
    }

    /**
     * Get the host index
     *
     * @return int Host index
     */
    public function getHostIndex()
    {
        return $this->hostIndex;
    }

    /**
     * @return Configuration
     */
    public function getConfig()
    {
        return $this->config;
    }

    /**
     * Operation createBatch
     *
     * Create batch
     *
     * @param  \AIStats\Sdk\Model\BatchRequest $batch_request batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatch'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\BatchResponse
     */
    public function createBatch($batch_request, string $contentType = self::contentTypes['createBatch'][0])
    {
        list($response) = $this->createBatchWithHttpInfo($batch_request, $contentType);
        return $response;
    }

    /**
     * Operation createBatchWithHttpInfo
     *
     * Create batch
     *
     * @param  \AIStats\Sdk\Model\BatchRequest $batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatch'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\BatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createBatchWithHttpInfo($batch_request, string $contentType = self::contentTypes['createBatch'][0])
    {
        $request = $this->createBatchRequest($batch_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\BatchResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\BatchResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\BatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createBatchAsync
     *
     * Create batch
     *
     * @param  \AIStats\Sdk\Model\BatchRequest $batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchAsync($batch_request, string $contentType = self::contentTypes['createBatch'][0])
    {
        return $this->createBatchAsyncWithHttpInfo($batch_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createBatchAsyncWithHttpInfo
     *
     * Create batch
     *
     * @param  \AIStats\Sdk\Model\BatchRequest $batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createBatchAsyncWithHttpInfo($batch_request, string $contentType = self::contentTypes['createBatch'][0])
    {
        $returnType = '\AIStats\Sdk\Model\BatchResponse';
        $request = $this->createBatchRequest($batch_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createBatch'
     *
     * @param  \AIStats\Sdk\Model\BatchRequest $batch_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createBatchRequest($batch_request, string $contentType = self::contentTypes['createBatch'][0])
    {

        // verify the required parameter 'batch_request' is set
        if ($batch_request === null || (is_array($batch_request) && count($batch_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_request when calling createBatch'
            );
        }


        $resourcePath = '/batches';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($batch_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($batch_request));
            } else {
                $httpBody = $batch_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createChatCompletion
     *
     * Create chat completion
     *
     * @param  \AIStats\Sdk\Model\ChatCompletionsRequest $chat_completions_request chat_completions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatCompletion'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ChatCompletionsResponse
     */
    public function createChatCompletion($chat_completions_request, string $contentType = self::contentTypes['createChatCompletion'][0])
    {
        list($response) = $this->createChatCompletionWithHttpInfo($chat_completions_request, $contentType);
        return $response;
    }

    /**
     * Operation createChatCompletionWithHttpInfo
     *
     * Create chat completion
     *
     * @param  \AIStats\Sdk\Model\ChatCompletionsRequest $chat_completions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatCompletion'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ChatCompletionsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createChatCompletionWithHttpInfo($chat_completions_request, string $contentType = self::contentTypes['createChatCompletion'][0])
    {
        $request = $this->createChatCompletionRequest($chat_completions_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ChatCompletionsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ChatCompletionsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ChatCompletionsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createChatCompletionAsync
     *
     * Create chat completion
     *
     * @param  \AIStats\Sdk\Model\ChatCompletionsRequest $chat_completions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChatCompletionAsync($chat_completions_request, string $contentType = self::contentTypes['createChatCompletion'][0])
    {
        return $this->createChatCompletionAsyncWithHttpInfo($chat_completions_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createChatCompletionAsyncWithHttpInfo
     *
     * Create chat completion
     *
     * @param  \AIStats\Sdk\Model\ChatCompletionsRequest $chat_completions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createChatCompletionAsyncWithHttpInfo($chat_completions_request, string $contentType = self::contentTypes['createChatCompletion'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ChatCompletionsResponse';
        $request = $this->createChatCompletionRequest($chat_completions_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createChatCompletion'
     *
     * @param  \AIStats\Sdk\Model\ChatCompletionsRequest $chat_completions_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createChatCompletion'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createChatCompletionRequest($chat_completions_request, string $contentType = self::contentTypes['createChatCompletion'][0])
    {

        // verify the required parameter 'chat_completions_request' is set
        if ($chat_completions_request === null || (is_array($chat_completions_request) && count($chat_completions_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $chat_completions_request when calling createChatCompletion'
            );
        }


        $resourcePath = '/chat/completions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($chat_completions_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($chat_completions_request));
            } else {
                $httpBody = $chat_completions_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createEmbedding
     *
     * Create embeddings
     *
     * @param  \AIStats\Sdk\Model\EmbeddingsRequest $embeddings_request embeddings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbedding'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\EmbeddingsResponse
     */
    public function createEmbedding($embeddings_request, string $contentType = self::contentTypes['createEmbedding'][0])
    {
        list($response) = $this->createEmbeddingWithHttpInfo($embeddings_request, $contentType);
        return $response;
    }

    /**
     * Operation createEmbeddingWithHttpInfo
     *
     * Create embeddings
     *
     * @param  \AIStats\Sdk\Model\EmbeddingsRequest $embeddings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbedding'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\EmbeddingsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createEmbeddingWithHttpInfo($embeddings_request, string $contentType = self::contentTypes['createEmbedding'][0])
    {
        $request = $this->createEmbeddingRequest($embeddings_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\EmbeddingsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\EmbeddingsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\EmbeddingsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createEmbeddingAsync
     *
     * Create embeddings
     *
     * @param  \AIStats\Sdk\Model\EmbeddingsRequest $embeddings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbedding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmbeddingAsync($embeddings_request, string $contentType = self::contentTypes['createEmbedding'][0])
    {
        return $this->createEmbeddingAsyncWithHttpInfo($embeddings_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createEmbeddingAsyncWithHttpInfo
     *
     * Create embeddings
     *
     * @param  \AIStats\Sdk\Model\EmbeddingsRequest $embeddings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbedding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createEmbeddingAsyncWithHttpInfo($embeddings_request, string $contentType = self::contentTypes['createEmbedding'][0])
    {
        $returnType = '\AIStats\Sdk\Model\EmbeddingsResponse';
        $request = $this->createEmbeddingRequest($embeddings_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createEmbedding'
     *
     * @param  \AIStats\Sdk\Model\EmbeddingsRequest $embeddings_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createEmbedding'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createEmbeddingRequest($embeddings_request, string $contentType = self::contentTypes['createEmbedding'][0])
    {

        // verify the required parameter 'embeddings_request' is set
        if ($embeddings_request === null || (is_array($embeddings_request) && count($embeddings_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $embeddings_request when calling createEmbedding'
            );
        }


        $resourcePath = '/embeddings';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($embeddings_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($embeddings_request));
            } else {
                $httpBody = $embeddings_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createImage
     *
     * Create image
     *
     * @param  \AIStats\Sdk\Model\ImagesGenerationRequest $images_generation_request images_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImage'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ImagesGenerationResponse
     */
    public function createImage($images_generation_request, string $contentType = self::contentTypes['createImage'][0])
    {
        list($response) = $this->createImageWithHttpInfo($images_generation_request, $contentType);
        return $response;
    }

    /**
     * Operation createImageWithHttpInfo
     *
     * Create image
     *
     * @param  \AIStats\Sdk\Model\ImagesGenerationRequest $images_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImage'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ImagesGenerationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createImageWithHttpInfo($images_generation_request, string $contentType = self::contentTypes['createImage'][0])
    {
        $request = $this->createImageRequest($images_generation_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ImagesGenerationResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ImagesGenerationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ImagesGenerationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createImageAsync
     *
     * Create image
     *
     * @param  \AIStats\Sdk\Model\ImagesGenerationRequest $images_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImageAsync($images_generation_request, string $contentType = self::contentTypes['createImage'][0])
    {
        return $this->createImageAsyncWithHttpInfo($images_generation_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createImageAsyncWithHttpInfo
     *
     * Create image
     *
     * @param  \AIStats\Sdk\Model\ImagesGenerationRequest $images_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImageAsyncWithHttpInfo($images_generation_request, string $contentType = self::contentTypes['createImage'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ImagesGenerationResponse';
        $request = $this->createImageRequest($images_generation_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createImage'
     *
     * @param  \AIStats\Sdk\Model\ImagesGenerationRequest $images_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImage'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createImageRequest($images_generation_request, string $contentType = self::contentTypes['createImage'][0])
    {

        // verify the required parameter 'images_generation_request' is set
        if ($images_generation_request === null || (is_array($images_generation_request) && count($images_generation_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $images_generation_request when calling createImage'
            );
        }


        $resourcePath = '/images/generations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($images_generation_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($images_generation_request));
            } else {
                $httpBody = $images_generation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createImageEdit
     *
     * Create image edit
     *
     * @param  string $model model (required)
     * @param  string $image image (required)
     * @param  string $prompt prompt (required)
     * @param  string|null $mask mask (optional)
     * @param  string|null $size size (optional)
     * @param  int|null $n n (optional)
     * @param  string|null $user user (optional)
     * @param  bool|null $meta meta (optional)
     * @param  bool|null $usage usage (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImageEdit'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ImagesEditResponse
     */
    public function createImageEdit($model, $image, $prompt, $mask = null, $size = null, $n = null, $user = null, $meta = null, $usage = null, string $contentType = self::contentTypes['createImageEdit'][0])
    {
        list($response) = $this->createImageEditWithHttpInfo($model, $image, $prompt, $mask, $size, $n, $user, $meta, $usage, $contentType);
        return $response;
    }

    /**
     * Operation createImageEditWithHttpInfo
     *
     * Create image edit
     *
     * @param  string $model (required)
     * @param  string $image (required)
     * @param  string $prompt (required)
     * @param  string|null $mask (optional)
     * @param  string|null $size (optional)
     * @param  int|null $n (optional)
     * @param  string|null $user (optional)
     * @param  bool|null $meta (optional)
     * @param  bool|null $usage (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImageEdit'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ImagesEditResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createImageEditWithHttpInfo($model, $image, $prompt, $mask = null, $size = null, $n = null, $user = null, $meta = null, $usage = null, string $contentType = self::contentTypes['createImageEdit'][0])
    {
        $request = $this->createImageEditRequest($model, $image, $prompt, $mask, $size, $n, $user, $meta, $usage, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ImagesEditResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ImagesEditResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ImagesEditResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createImageEditAsync
     *
     * Create image edit
     *
     * @param  string $model (required)
     * @param  string $image (required)
     * @param  string $prompt (required)
     * @param  string|null $mask (optional)
     * @param  string|null $size (optional)
     * @param  int|null $n (optional)
     * @param  string|null $user (optional)
     * @param  bool|null $meta (optional)
     * @param  bool|null $usage (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImageEdit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImageEditAsync($model, $image, $prompt, $mask = null, $size = null, $n = null, $user = null, $meta = null, $usage = null, string $contentType = self::contentTypes['createImageEdit'][0])
    {
        return $this->createImageEditAsyncWithHttpInfo($model, $image, $prompt, $mask, $size, $n, $user, $meta, $usage, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createImageEditAsyncWithHttpInfo
     *
     * Create image edit
     *
     * @param  string $model (required)
     * @param  string $image (required)
     * @param  string $prompt (required)
     * @param  string|null $mask (optional)
     * @param  string|null $size (optional)
     * @param  int|null $n (optional)
     * @param  string|null $user (optional)
     * @param  bool|null $meta (optional)
     * @param  bool|null $usage (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImageEdit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createImageEditAsyncWithHttpInfo($model, $image, $prompt, $mask = null, $size = null, $n = null, $user = null, $meta = null, $usage = null, string $contentType = self::contentTypes['createImageEdit'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ImagesEditResponse';
        $request = $this->createImageEditRequest($model, $image, $prompt, $mask, $size, $n, $user, $meta, $usage, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createImageEdit'
     *
     * @param  string $model (required)
     * @param  string $image (required)
     * @param  string $prompt (required)
     * @param  string|null $mask (optional)
     * @param  string|null $size (optional)
     * @param  int|null $n (optional)
     * @param  string|null $user (optional)
     * @param  bool|null $meta (optional)
     * @param  bool|null $usage (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createImageEdit'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createImageEditRequest($model, $image, $prompt, $mask = null, $size = null, $n = null, $user = null, $meta = null, $usage = null, string $contentType = self::contentTypes['createImageEdit'][0])
    {

        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling createImageEdit'
            );
        }

        // verify the required parameter 'image' is set
        if ($image === null || (is_array($image) && count($image) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $image when calling createImageEdit'
            );
        }

        // verify the required parameter 'prompt' is set
        if ($prompt === null || (is_array($prompt) && count($prompt) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $prompt when calling createImageEdit'
            );
        }



        if ($n !== null && $n > 10) {
            throw new \InvalidArgumentException('invalid value for "$n" when calling DefaultApi.createImageEdit, must be smaller than or equal to 10.');
        }
        if ($n !== null && $n < 1) {
            throw new \InvalidArgumentException('invalid value for "$n" when calling DefaultApi.createImageEdit, must be bigger than or equal to 1.');
        }
        




        $resourcePath = '/images/edits';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'model' => $model,
            'image' => $image,
            'mask' => $mask,
            'prompt' => $prompt,
            'size' => $size,
            'n' => $n,
            'user' => $user,
            'meta' => $meta,
            'usage' => $usage,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createModeration
     *
     * Create moderation
     *
     * @param  \AIStats\Sdk\Model\ModerationsRequest $moderations_request moderations_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModeration'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ModerationsResponse
     */
    public function createModeration($moderations_request, string $contentType = self::contentTypes['createModeration'][0])
    {
        list($response) = $this->createModerationWithHttpInfo($moderations_request, $contentType);
        return $response;
    }

    /**
     * Operation createModerationWithHttpInfo
     *
     * Create moderation
     *
     * @param  \AIStats\Sdk\Model\ModerationsRequest $moderations_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModeration'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ModerationsResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createModerationWithHttpInfo($moderations_request, string $contentType = self::contentTypes['createModeration'][0])
    {
        $request = $this->createModerationRequest($moderations_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ModerationsResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ModerationsResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ModerationsResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createModerationAsync
     *
     * Create moderation
     *
     * @param  \AIStats\Sdk\Model\ModerationsRequest $moderations_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModeration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModerationAsync($moderations_request, string $contentType = self::contentTypes['createModeration'][0])
    {
        return $this->createModerationAsyncWithHttpInfo($moderations_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createModerationAsyncWithHttpInfo
     *
     * Create moderation
     *
     * @param  \AIStats\Sdk\Model\ModerationsRequest $moderations_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModeration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createModerationAsyncWithHttpInfo($moderations_request, string $contentType = self::contentTypes['createModeration'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ModerationsResponse';
        $request = $this->createModerationRequest($moderations_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createModeration'
     *
     * @param  \AIStats\Sdk\Model\ModerationsRequest $moderations_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createModeration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createModerationRequest($moderations_request, string $contentType = self::contentTypes['createModeration'][0])
    {

        // verify the required parameter 'moderations_request' is set
        if ($moderations_request === null || (is_array($moderations_request) && count($moderations_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $moderations_request when calling createModeration'
            );
        }


        $resourcePath = '/moderations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($moderations_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($moderations_request));
            } else {
                $httpBody = $moderations_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createResponse
     *
     * Create response
     *
     * @param  \AIStats\Sdk\Model\ResponsesRequest $responses_request responses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createResponse'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ResponsesResponse
     */
    public function createResponse($responses_request, string $contentType = self::contentTypes['createResponse'][0])
    {
        list($response) = $this->createResponseWithHttpInfo($responses_request, $contentType);
        return $response;
    }

    /**
     * Operation createResponseWithHttpInfo
     *
     * Create response
     *
     * @param  \AIStats\Sdk\Model\ResponsesRequest $responses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createResponse'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ResponsesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createResponseWithHttpInfo($responses_request, string $contentType = self::contentTypes['createResponse'][0])
    {
        $request = $this->createResponseRequest($responses_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ResponsesResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ResponsesResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ResponsesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createResponseAsync
     *
     * Create response
     *
     * @param  \AIStats\Sdk\Model\ResponsesRequest $responses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createResponseAsync($responses_request, string $contentType = self::contentTypes['createResponse'][0])
    {
        return $this->createResponseAsyncWithHttpInfo($responses_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createResponseAsyncWithHttpInfo
     *
     * Create response
     *
     * @param  \AIStats\Sdk\Model\ResponsesRequest $responses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createResponseAsyncWithHttpInfo($responses_request, string $contentType = self::contentTypes['createResponse'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ResponsesResponse';
        $request = $this->createResponseRequest($responses_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createResponse'
     *
     * @param  \AIStats\Sdk\Model\ResponsesRequest $responses_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createResponse'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createResponseRequest($responses_request, string $contentType = self::contentTypes['createResponse'][0])
    {

        // verify the required parameter 'responses_request' is set
        if ($responses_request === null || (is_array($responses_request) && count($responses_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $responses_request when calling createResponse'
            );
        }


        $resourcePath = '/responses';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($responses_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($responses_request));
            } else {
                $httpBody = $responses_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createSpeech
     *
     * Generate speech
     *
     * @param  \AIStats\Sdk\Model\AudioSpeechRequest $audio_speech_request audio_speech_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpeech'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \SplFileObject
     */
    public function createSpeech($audio_speech_request, string $contentType = self::contentTypes['createSpeech'][0])
    {
        list($response) = $this->createSpeechWithHttpInfo($audio_speech_request, $contentType);
        return $response;
    }

    /**
     * Operation createSpeechWithHttpInfo
     *
     * Generate speech
     *
     * @param  \AIStats\Sdk\Model\AudioSpeechRequest $audio_speech_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpeech'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \SplFileObject, HTTP status code, HTTP response headers (array of strings)
     */
    public function createSpeechWithHttpInfo($audio_speech_request, string $contentType = self::contentTypes['createSpeech'][0])
    {
        $request = $this->createSpeechRequest($audio_speech_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\SplFileObject',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\SplFileObject',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\SplFileObject',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createSpeechAsync
     *
     * Generate speech
     *
     * @param  \AIStats\Sdk\Model\AudioSpeechRequest $audio_speech_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpeech'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSpeechAsync($audio_speech_request, string $contentType = self::contentTypes['createSpeech'][0])
    {
        return $this->createSpeechAsyncWithHttpInfo($audio_speech_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createSpeechAsyncWithHttpInfo
     *
     * Generate speech
     *
     * @param  \AIStats\Sdk\Model\AudioSpeechRequest $audio_speech_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpeech'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createSpeechAsyncWithHttpInfo($audio_speech_request, string $contentType = self::contentTypes['createSpeech'][0])
    {
        $returnType = '\SplFileObject';
        $request = $this->createSpeechRequest($audio_speech_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createSpeech'
     *
     * @param  \AIStats\Sdk\Model\AudioSpeechRequest $audio_speech_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createSpeech'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createSpeechRequest($audio_speech_request, string $contentType = self::contentTypes['createSpeech'][0])
    {

        // verify the required parameter 'audio_speech_request' is set
        if ($audio_speech_request === null || (is_array($audio_speech_request) && count($audio_speech_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $audio_speech_request when calling createSpeech'
            );
        }


        $resourcePath = '/audio/speech';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['audio/mpeg', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($audio_speech_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($audio_speech_request));
            } else {
                $httpBody = $audio_speech_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTranscription
     *
     * Create transcription
     *
     * @param  string $model model (required)
     * @param  string|null $audio_url audio_url (optional)
     * @param  string|null $audio_b64 audio_b64 (optional)
     * @param  string|null $language language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranscription'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\AudioTranscriptionResponse
     */
    public function createTranscription($model, $audio_url = null, $audio_b64 = null, $language = null, string $contentType = self::contentTypes['createTranscription'][0])
    {
        list($response) = $this->createTranscriptionWithHttpInfo($model, $audio_url, $audio_b64, $language, $contentType);
        return $response;
    }

    /**
     * Operation createTranscriptionWithHttpInfo
     *
     * Create transcription
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranscription'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\AudioTranscriptionResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTranscriptionWithHttpInfo($model, $audio_url = null, $audio_b64 = null, $language = null, string $contentType = self::contentTypes['createTranscription'][0])
    {
        $request = $this->createTranscriptionRequest($model, $audio_url, $audio_b64, $language, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\AudioTranscriptionResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\AudioTranscriptionResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\AudioTranscriptionResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTranscriptionAsync
     *
     * Create transcription
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTranscriptionAsync($model, $audio_url = null, $audio_b64 = null, $language = null, string $contentType = self::contentTypes['createTranscription'][0])
    {
        return $this->createTranscriptionAsyncWithHttpInfo($model, $audio_url, $audio_b64, $language, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTranscriptionAsyncWithHttpInfo
     *
     * Create transcription
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTranscriptionAsyncWithHttpInfo($model, $audio_url = null, $audio_b64 = null, $language = null, string $contentType = self::contentTypes['createTranscription'][0])
    {
        $returnType = '\AIStats\Sdk\Model\AudioTranscriptionResponse';
        $request = $this->createTranscriptionRequest($model, $audio_url, $audio_b64, $language, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTranscription'
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranscription'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTranscriptionRequest($model, $audio_url = null, $audio_b64 = null, $language = null, string $contentType = self::contentTypes['createTranscription'][0])
    {

        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling createTranscription'
            );
        }





        $resourcePath = '/audio/transcriptions';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'model' => $model,
            'audio_url' => $audio_url,
            'audio_b64' => $audio_b64,
            'language' => $language,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createTranslation
     *
     * Create translation
     *
     * @param  string $model model (required)
     * @param  string|null $audio_url audio_url (optional)
     * @param  string|null $audio_b64 audio_b64 (optional)
     * @param  string|null $language language (optional)
     * @param  string|null $prompt prompt (optional)
     * @param  float|null $temperature temperature (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranslation'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\AudioTranslationResponse
     */
    public function createTranslation($model, $audio_url = null, $audio_b64 = null, $language = null, $prompt = null, $temperature = null, string $contentType = self::contentTypes['createTranslation'][0])
    {
        list($response) = $this->createTranslationWithHttpInfo($model, $audio_url, $audio_b64, $language, $prompt, $temperature, $contentType);
        return $response;
    }

    /**
     * Operation createTranslationWithHttpInfo
     *
     * Create translation
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string|null $prompt (optional)
     * @param  float|null $temperature (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranslation'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\AudioTranslationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createTranslationWithHttpInfo($model, $audio_url = null, $audio_b64 = null, $language = null, $prompt = null, $temperature = null, string $contentType = self::contentTypes['createTranslation'][0])
    {
        $request = $this->createTranslationRequest($model, $audio_url, $audio_b64, $language, $prompt, $temperature, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\AudioTranslationResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\AudioTranslationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\AudioTranslationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createTranslationAsync
     *
     * Create translation
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string|null $prompt (optional)
     * @param  float|null $temperature (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranslation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTranslationAsync($model, $audio_url = null, $audio_b64 = null, $language = null, $prompt = null, $temperature = null, string $contentType = self::contentTypes['createTranslation'][0])
    {
        return $this->createTranslationAsyncWithHttpInfo($model, $audio_url, $audio_b64, $language, $prompt, $temperature, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createTranslationAsyncWithHttpInfo
     *
     * Create translation
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string|null $prompt (optional)
     * @param  float|null $temperature (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranslation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createTranslationAsyncWithHttpInfo($model, $audio_url = null, $audio_b64 = null, $language = null, $prompt = null, $temperature = null, string $contentType = self::contentTypes['createTranslation'][0])
    {
        $returnType = '\AIStats\Sdk\Model\AudioTranslationResponse';
        $request = $this->createTranslationRequest($model, $audio_url, $audio_b64, $language, $prompt, $temperature, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createTranslation'
     *
     * @param  string $model (required)
     * @param  string|null $audio_url (optional)
     * @param  string|null $audio_b64 (optional)
     * @param  string|null $language (optional)
     * @param  string|null $prompt (optional)
     * @param  float|null $temperature (optional)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createTranslation'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createTranslationRequest($model, $audio_url = null, $audio_b64 = null, $language = null, $prompt = null, $temperature = null, string $contentType = self::contentTypes['createTranslation'][0])
    {

        // verify the required parameter 'model' is set
        if ($model === null || (is_array($model) && count($model) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $model when calling createTranslation'
            );
        }





        if ($temperature !== null && $temperature > 2) {
            throw new \InvalidArgumentException('invalid value for "$temperature" when calling DefaultApi.createTranslation, must be smaller than or equal to 2.');
        }
        if ($temperature !== null && $temperature < 0) {
            throw new \InvalidArgumentException('invalid value for "$temperature" when calling DefaultApi.createTranslation, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/audio/translations';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'model' => $model,
            'audio_url' => $audio_url,
            'audio_b64' => $audio_b64,
            'language' => $language,
            'prompt' => $prompt,
            'temperature' => $temperature,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation createVideo
     *
     * Create video
     *
     * @param  \AIStats\Sdk\Model\VideoGenerationRequest $video_generation_request video_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVideo'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\VideoGenerationResponse
     */
    public function createVideo($video_generation_request, string $contentType = self::contentTypes['createVideo'][0])
    {
        list($response) = $this->createVideoWithHttpInfo($video_generation_request, $contentType);
        return $response;
    }

    /**
     * Operation createVideoWithHttpInfo
     *
     * Create video
     *
     * @param  \AIStats\Sdk\Model\VideoGenerationRequest $video_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVideo'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\VideoGenerationResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function createVideoWithHttpInfo($video_generation_request, string $contentType = self::contentTypes['createVideo'][0])
    {
        $request = $this->createVideoRequest($video_generation_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\VideoGenerationResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\VideoGenerationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\VideoGenerationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation createVideoAsync
     *
     * Create video
     *
     * @param  \AIStats\Sdk\Model\VideoGenerationRequest $video_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVideoAsync($video_generation_request, string $contentType = self::contentTypes['createVideo'][0])
    {
        return $this->createVideoAsyncWithHttpInfo($video_generation_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation createVideoAsyncWithHttpInfo
     *
     * Create video
     *
     * @param  \AIStats\Sdk\Model\VideoGenerationRequest $video_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function createVideoAsyncWithHttpInfo($video_generation_request, string $contentType = self::contentTypes['createVideo'][0])
    {
        $returnType = '\AIStats\Sdk\Model\VideoGenerationResponse';
        $request = $this->createVideoRequest($video_generation_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'createVideo'
     *
     * @param  \AIStats\Sdk\Model\VideoGenerationRequest $video_generation_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['createVideo'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function createVideoRequest($video_generation_request, string $contentType = self::contentTypes['createVideo'][0])
    {

        // verify the required parameter 'video_generation_request' is set
        if ($video_generation_request === null || (is_array($video_generation_request) && count($video_generation_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $video_generation_request when calling createVideo'
            );
        }


        $resourcePath = '/videos';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($video_generation_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($video_generation_request));
            } else {
                $httpBody = $video_generation_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getAnalytics
     *
     * Get analytics
     *
     * @param  \AIStats\Sdk\Model\GetAnalyticsRequest $get_analytics_request get_analytics_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalytics'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\GetAnalytics200Response
     */
    public function getAnalytics($get_analytics_request, string $contentType = self::contentTypes['getAnalytics'][0])
    {
        list($response) = $this->getAnalyticsWithHttpInfo($get_analytics_request, $contentType);
        return $response;
    }

    /**
     * Operation getAnalyticsWithHttpInfo
     *
     * Get analytics
     *
     * @param  \AIStats\Sdk\Model\GetAnalyticsRequest $get_analytics_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalytics'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\GetAnalytics200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getAnalyticsWithHttpInfo($get_analytics_request, string $contentType = self::contentTypes['getAnalytics'][0])
    {
        $request = $this->getAnalyticsRequest($get_analytics_request, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\GetAnalytics200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\GetAnalytics200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\GetAnalytics200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getAnalyticsAsync
     *
     * Get analytics
     *
     * @param  \AIStats\Sdk\Model\GetAnalyticsRequest $get_analytics_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalytics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyticsAsync($get_analytics_request, string $contentType = self::contentTypes['getAnalytics'][0])
    {
        return $this->getAnalyticsAsyncWithHttpInfo($get_analytics_request, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getAnalyticsAsyncWithHttpInfo
     *
     * Get analytics
     *
     * @param  \AIStats\Sdk\Model\GetAnalyticsRequest $get_analytics_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalytics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getAnalyticsAsyncWithHttpInfo($get_analytics_request, string $contentType = self::contentTypes['getAnalytics'][0])
    {
        $returnType = '\AIStats\Sdk\Model\GetAnalytics200Response';
        $request = $this->getAnalyticsRequest($get_analytics_request, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getAnalytics'
     *
     * @param  \AIStats\Sdk\Model\GetAnalyticsRequest $get_analytics_request (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getAnalytics'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getAnalyticsRequest($get_analytics_request, string $contentType = self::contentTypes['getAnalytics'][0])
    {

        // verify the required parameter 'get_analytics_request' is set
        if ($get_analytics_request === null || (is_array($get_analytics_request) && count($get_analytics_request) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $get_analytics_request when calling getAnalytics'
            );
        }


        $resourcePath = '/analytics';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (isset($get_analytics_request)) {
            if (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the body
                $httpBody = \GuzzleHttp\Utils::jsonEncode(ObjectSerializer::sanitizeForSerialization($get_analytics_request));
            } else {
                $httpBody = $get_analytics_request;
            }
        } elseif (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation getGeneration
     *
     * Get generation
     *
     * @param  string $id The ID of the generation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGeneration'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\GenerationResponse|\AIStats\Sdk\Model\GetGeneration401Response|\AIStats\Sdk\Model\GetGeneration404Response
     */
    public function getGeneration($id, string $contentType = self::contentTypes['getGeneration'][0])
    {
        list($response) = $this->getGenerationWithHttpInfo($id, $contentType);
        return $response;
    }

    /**
     * Operation getGenerationWithHttpInfo
     *
     * Get generation
     *
     * @param  string $id The ID of the generation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGeneration'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\GenerationResponse|\AIStats\Sdk\Model\GetGeneration401Response|\AIStats\Sdk\Model\GetGeneration404Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function getGenerationWithHttpInfo($id, string $contentType = self::contentTypes['getGeneration'][0])
    {
        $request = $this->getGenerationRequest($id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\GenerationResponse',
                        $request,
                        $response,
                    );
                case 401:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\GetGeneration401Response',
                        $request,
                        $response,
                    );
                case 404:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\GetGeneration404Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\GenerationResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\GenerationResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 401:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\GetGeneration401Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 404:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\GetGeneration404Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation getGenerationAsync
     *
     * Get generation
     *
     * @param  string $id The ID of the generation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGeneration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenerationAsync($id, string $contentType = self::contentTypes['getGeneration'][0])
    {
        return $this->getGenerationAsyncWithHttpInfo($id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation getGenerationAsyncWithHttpInfo
     *
     * Get generation
     *
     * @param  string $id The ID of the generation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGeneration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function getGenerationAsyncWithHttpInfo($id, string $contentType = self::contentTypes['getGeneration'][0])
    {
        $returnType = '\AIStats\Sdk\Model\GenerationResponse';
        $request = $this->getGenerationRequest($id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'getGeneration'
     *
     * @param  string $id The ID of the generation (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['getGeneration'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function getGenerationRequest($id, string $contentType = self::contentTypes['getGeneration'][0])
    {

        // verify the required parameter 'id' is set
        if ($id === null || (is_array($id) && count($id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $id when calling getGeneration'
            );
        }


        $resourcePath = '/generation';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $id,
            'id', // param base name
            'string', // openApiType
            'form', // style
            true, // explode
            true // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation healthz
     *
     * Health check
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['healthz'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\Healthz200Response
     */
    public function healthz(string $contentType = self::contentTypes['healthz'][0])
    {
        list($response) = $this->healthzWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation healthzWithHttpInfo
     *
     * Health check
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['healthz'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\Healthz200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function healthzWithHttpInfo(string $contentType = self::contentTypes['healthz'][0])
    {
        $request = $this->healthzRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\Healthz200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\Healthz200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\Healthz200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation healthzAsync
     *
     * Health check
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['healthz'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function healthzAsync(string $contentType = self::contentTypes['healthz'][0])
    {
        return $this->healthzAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation healthzAsyncWithHttpInfo
     *
     * Health check
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['healthz'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function healthzAsyncWithHttpInfo(string $contentType = self::contentTypes['healthz'][0])
    {
        $returnType = '\AIStats\Sdk\Model\Healthz200Response';
        $request = $this->healthzRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'healthz'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['healthz'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function healthzRequest(string $contentType = self::contentTypes['healthz'][0])
    {


        $resourcePath = '/healthz';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listFiles
     *
     * List files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ListFilesResponse
     */
    public function listFiles(string $contentType = self::contentTypes['listFiles'][0])
    {
        list($response) = $this->listFilesWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation listFilesWithHttpInfo
     *
     * List files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ListFilesResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function listFilesWithHttpInfo(string $contentType = self::contentTypes['listFiles'][0])
    {
        $request = $this->listFilesRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ListFilesResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ListFilesResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ListFilesResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listFilesAsync
     *
     * List files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFilesAsync(string $contentType = self::contentTypes['listFiles'][0])
    {
        return $this->listFilesAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listFilesAsyncWithHttpInfo
     *
     * List files
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listFilesAsyncWithHttpInfo(string $contentType = self::contentTypes['listFiles'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ListFilesResponse';
        $request = $this->listFilesRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listFiles'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listFiles'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listFilesRequest(string $contentType = self::contentTypes['listFiles'][0])
    {


        $resourcePath = '/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation listModels
     *
     * List models
     *
     * @param  string[]|null $endpoints Filter by endpoints (optional)
     * @param  \AIStats\Sdk\Model\ListModelsOrganisationParameter|null $organisation Filter by organisation (optional)
     * @param  string[]|null $input_types Filter by input types (optional)
     * @param  string[]|null $output_types Filter by output types (optional)
     * @param  string[]|null $params Filter by params (optional)
     * @param  int|null $limit Limit the number of results (optional, default to 50)
     * @param  int|null $offset Offset for pagination (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\ListModels200Response|\AIStats\Sdk\Model\ListModels500Response
     */
    public function listModels($endpoints = null, $organisation = null, $input_types = null, $output_types = null, $params = null, $limit = 50, $offset = 0, string $contentType = self::contentTypes['listModels'][0])
    {
        list($response) = $this->listModelsWithHttpInfo($endpoints, $organisation, $input_types, $output_types, $params, $limit, $offset, $contentType);
        return $response;
    }

    /**
     * Operation listModelsWithHttpInfo
     *
     * List models
     *
     * @param  string[]|null $endpoints Filter by endpoints (optional)
     * @param  \AIStats\Sdk\Model\ListModelsOrganisationParameter|null $organisation Filter by organisation (optional)
     * @param  string[]|null $input_types Filter by input types (optional)
     * @param  string[]|null $output_types Filter by output types (optional)
     * @param  string[]|null $params Filter by params (optional)
     * @param  int|null $limit Limit the number of results (optional, default to 50)
     * @param  int|null $offset Offset for pagination (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\ListModels200Response|\AIStats\Sdk\Model\ListModels500Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function listModelsWithHttpInfo($endpoints = null, $organisation = null, $input_types = null, $output_types = null, $params = null, $limit = 50, $offset = 0, string $contentType = self::contentTypes['listModels'][0])
    {
        $request = $this->listModelsRequest($endpoints, $organisation, $input_types, $output_types, $params, $limit, $offset, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ListModels200Response',
                        $request,
                        $response,
                    );
                case 500:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\ListModels500Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\ListModels200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ListModels200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
                case 500:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\ListModels500Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation listModelsAsync
     *
     * List models
     *
     * @param  string[]|null $endpoints Filter by endpoints (optional)
     * @param  \AIStats\Sdk\Model\ListModelsOrganisationParameter|null $organisation Filter by organisation (optional)
     * @param  string[]|null $input_types Filter by input types (optional)
     * @param  string[]|null $output_types Filter by output types (optional)
     * @param  string[]|null $params Filter by params (optional)
     * @param  int|null $limit Limit the number of results (optional, default to 50)
     * @param  int|null $offset Offset for pagination (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelsAsync($endpoints = null, $organisation = null, $input_types = null, $output_types = null, $params = null, $limit = 50, $offset = 0, string $contentType = self::contentTypes['listModels'][0])
    {
        return $this->listModelsAsyncWithHttpInfo($endpoints, $organisation, $input_types, $output_types, $params, $limit, $offset, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation listModelsAsyncWithHttpInfo
     *
     * List models
     *
     * @param  string[]|null $endpoints Filter by endpoints (optional)
     * @param  \AIStats\Sdk\Model\ListModelsOrganisationParameter|null $organisation Filter by organisation (optional)
     * @param  string[]|null $input_types Filter by input types (optional)
     * @param  string[]|null $output_types Filter by output types (optional)
     * @param  string[]|null $params Filter by params (optional)
     * @param  int|null $limit Limit the number of results (optional, default to 50)
     * @param  int|null $offset Offset for pagination (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function listModelsAsyncWithHttpInfo($endpoints = null, $organisation = null, $input_types = null, $output_types = null, $params = null, $limit = 50, $offset = 0, string $contentType = self::contentTypes['listModels'][0])
    {
        $returnType = '\AIStats\Sdk\Model\ListModels200Response';
        $request = $this->listModelsRequest($endpoints, $organisation, $input_types, $output_types, $params, $limit, $offset, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'listModels'
     *
     * @param  string[]|null $endpoints Filter by endpoints (optional)
     * @param  \AIStats\Sdk\Model\ListModelsOrganisationParameter|null $organisation Filter by organisation (optional)
     * @param  string[]|null $input_types Filter by input types (optional)
     * @param  string[]|null $output_types Filter by output types (optional)
     * @param  string[]|null $params Filter by params (optional)
     * @param  int|null $limit Limit the number of results (optional, default to 50)
     * @param  int|null $offset Offset for pagination (optional, default to 0)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['listModels'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function listModelsRequest($endpoints = null, $organisation = null, $input_types = null, $output_types = null, $params = null, $limit = 50, $offset = 0, string $contentType = self::contentTypes['listModels'][0])
    {






        if ($limit !== null && $limit > 250) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.listModels, must be smaller than or equal to 250.');
        }
        if ($limit !== null && $limit < 1) {
            throw new \InvalidArgumentException('invalid value for "$limit" when calling DefaultApi.listModels, must be bigger than or equal to 1.');
        }
        
        if ($offset !== null && $offset < 0) {
            throw new \InvalidArgumentException('invalid value for "$offset" when calling DefaultApi.listModels, must be bigger than or equal to 0.');
        }
        

        $resourcePath = '/models';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;

        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $endpoints,
            'endpoints', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $organisation,
            'organisation', // param base name
            '\AIStats\Sdk\Model\OrganisationId|array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $input_types,
            'input_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $output_types,
            'output_types', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $params,
            'params', // param base name
            'array', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $limit,
            'limit', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);
        // query params
        $queryParams = array_merge($queryParams, ObjectSerializer::toQueryValue(
            $offset,
            'offset', // param base name
            'integer', // openApiType
            'form', // style
            true, // explode
            false // required
        ) ?? []);




        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveBatch
     *
     * Retrieve batch
     *
     * @param  string $batch_id The ID of the batch to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveBatch'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\BatchResponse
     */
    public function retrieveBatch($batch_id, string $contentType = self::contentTypes['retrieveBatch'][0])
    {
        list($response) = $this->retrieveBatchWithHttpInfo($batch_id, $contentType);
        return $response;
    }

    /**
     * Operation retrieveBatchWithHttpInfo
     *
     * Retrieve batch
     *
     * @param  string $batch_id The ID of the batch to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveBatch'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\BatchResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveBatchWithHttpInfo($batch_id, string $contentType = self::contentTypes['retrieveBatch'][0])
    {
        $request = $this->retrieveBatchRequest($batch_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\BatchResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\BatchResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\BatchResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation retrieveBatchAsync
     *
     * Retrieve batch
     *
     * @param  string $batch_id The ID of the batch to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveBatchAsync($batch_id, string $contentType = self::contentTypes['retrieveBatch'][0])
    {
        return $this->retrieveBatchAsyncWithHttpInfo($batch_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveBatchAsyncWithHttpInfo
     *
     * Retrieve batch
     *
     * @param  string $batch_id The ID of the batch to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveBatchAsyncWithHttpInfo($batch_id, string $contentType = self::contentTypes['retrieveBatch'][0])
    {
        $returnType = '\AIStats\Sdk\Model\BatchResponse';
        $request = $this->retrieveBatchRequest($batch_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveBatch'
     *
     * @param  string $batch_id The ID of the batch to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveBatch'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retrieveBatchRequest($batch_id, string $contentType = self::contentTypes['retrieveBatch'][0])
    {

        // verify the required parameter 'batch_id' is set
        if ($batch_id === null || (is_array($batch_id) && count($batch_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $batch_id when calling retrieveBatch'
            );
        }


        $resourcePath = '/batches/{batch_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($batch_id !== null) {
            $resourcePath = str_replace(
                '{' . 'batch_id' . '}',
                ObjectSerializer::toPathValue($batch_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation retrieveFile
     *
     * Retrieve file
     *
     * @param  string $file_id The ID of the file to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveFile'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\FileResponse
     */
    public function retrieveFile($file_id, string $contentType = self::contentTypes['retrieveFile'][0])
    {
        list($response) = $this->retrieveFileWithHttpInfo($file_id, $contentType);
        return $response;
    }

    /**
     * Operation retrieveFileWithHttpInfo
     *
     * Retrieve file
     *
     * @param  string $file_id The ID of the file to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveFile'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function retrieveFileWithHttpInfo($file_id, string $contentType = self::contentTypes['retrieveFile'][0])
    {
        $request = $this->retrieveFileRequest($file_id, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\FileResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\FileResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation retrieveFileAsync
     *
     * Retrieve file
     *
     * @param  string $file_id The ID of the file to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveFileAsync($file_id, string $contentType = self::contentTypes['retrieveFile'][0])
    {
        return $this->retrieveFileAsyncWithHttpInfo($file_id, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation retrieveFileAsyncWithHttpInfo
     *
     * Retrieve file
     *
     * @param  string $file_id The ID of the file to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function retrieveFileAsyncWithHttpInfo($file_id, string $contentType = self::contentTypes['retrieveFile'][0])
    {
        $returnType = '\AIStats\Sdk\Model\FileResponse';
        $request = $this->retrieveFileRequest($file_id, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'retrieveFile'
     *
     * @param  string $file_id The ID of the file to retrieve. (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['retrieveFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function retrieveFileRequest($file_id, string $contentType = self::contentTypes['retrieveFile'][0])
    {

        // verify the required parameter 'file_id' is set
        if ($file_id === null || (is_array($file_id) && count($file_id) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file_id when calling retrieveFile'
            );
        }


        $resourcePath = '/files/{file_id}';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;



        // path params
        if ($file_id !== null) {
            $resourcePath = str_replace(
                '{' . 'file_id' . '}',
                ObjectSerializer::toPathValue($file_id),
                $resourcePath
            );
        }


        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation root
     *
     * Root endpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['root'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\Root200Response
     */
    public function root(string $contentType = self::contentTypes['root'][0])
    {
        list($response) = $this->rootWithHttpInfo($contentType);
        return $response;
    }

    /**
     * Operation rootWithHttpInfo
     *
     * Root endpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['root'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\Root200Response, HTTP status code, HTTP response headers (array of strings)
     */
    public function rootWithHttpInfo(string $contentType = self::contentTypes['root'][0])
    {
        $request = $this->rootRequest($contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\Root200Response',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\Root200Response',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\Root200Response',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation rootAsync
     *
     * Root endpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['root'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rootAsync(string $contentType = self::contentTypes['root'][0])
    {
        return $this->rootAsyncWithHttpInfo($contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation rootAsyncWithHttpInfo
     *
     * Root endpoint
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['root'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function rootAsyncWithHttpInfo(string $contentType = self::contentTypes['root'][0])
    {
        $returnType = '\AIStats\Sdk\Model\Root200Response';
        $request = $this->rootRequest($contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'root'
     *
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['root'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function rootRequest(string $contentType = self::contentTypes['root'][0])
    {


        $resourcePath = '/';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;





        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'GET',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Operation uploadFile
     *
     * Upload file
     *
     * @param  \SplFileObject $file file (required)
     * @param  string $purpose purpose (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return \AIStats\Sdk\Model\FileResponse
     */
    public function uploadFile($file, $purpose, string $contentType = self::contentTypes['uploadFile'][0])
    {
        list($response) = $this->uploadFileWithHttpInfo($file, $purpose, $contentType);
        return $response;
    }

    /**
     * Operation uploadFileWithHttpInfo
     *
     * Upload file
     *
     * @param  \SplFileObject $file (required)
     * @param  string $purpose (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \AIStats\Sdk\ApiException on non-2xx response or if the response body is not in the expected format
     * @throws \InvalidArgumentException
     * @return array of \AIStats\Sdk\Model\FileResponse, HTTP status code, HTTP response headers (array of strings)
     */
    public function uploadFileWithHttpInfo($file, $purpose, string $contentType = self::contentTypes['uploadFile'][0])
    {
        $request = $this->uploadFileRequest($file, $purpose, $contentType);

        try {
            $options = $this->createHttpClientOption();
            try {
                $response = $this->client->send($request, $options);
            } catch (RequestException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    $e->getResponse() ? $e->getResponse()->getHeaders() : null,
                    $e->getResponse() ? (string) $e->getResponse()->getBody() : null
                );
            } catch (ConnectException $e) {
                throw new ApiException(
                    "[{$e->getCode()}] {$e->getMessage()}",
                    (int) $e->getCode(),
                    null,
                    null
                );
            }

            $statusCode = $response->getStatusCode();


            switch($statusCode) {
                case 200:
                    return $this->handleResponseWithDataType(
                        '\AIStats\Sdk\Model\FileResponse',
                        $request,
                        $response,
                    );
            }

            

            if ($statusCode < 200 || $statusCode > 299) {
                throw new ApiException(
                    sprintf(
                        '[%d] Error connecting to the API (%s)',
                        $statusCode,
                        (string) $request->getUri()
                    ),
                    $statusCode,
                    $response->getHeaders(),
                    (string) $response->getBody()
                );
            }

            return $this->handleResponseWithDataType(
                '\AIStats\Sdk\Model\FileResponse',
                $request,
                $response,
            );
        } catch (ApiException $e) {
            switch ($e->getCode()) {
                case 200:
                    $data = ObjectSerializer::deserialize(
                        $e->getResponseBody(),
                        '\AIStats\Sdk\Model\FileResponse',
                        $e->getResponseHeaders()
                    );
                    $e->setResponseObject($data);
                    throw $e;
            }
        

            throw $e;
        }
    }

    /**
     * Operation uploadFileAsync
     *
     * Upload file
     *
     * @param  \SplFileObject $file (required)
     * @param  string $purpose (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsync($file, $purpose, string $contentType = self::contentTypes['uploadFile'][0])
    {
        return $this->uploadFileAsyncWithHttpInfo($file, $purpose, $contentType)
            ->then(
                function ($response) {
                    return $response[0];
                }
            );
    }

    /**
     * Operation uploadFileAsyncWithHttpInfo
     *
     * Upload file
     *
     * @param  \SplFileObject $file (required)
     * @param  string $purpose (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Promise\PromiseInterface
     */
    public function uploadFileAsyncWithHttpInfo($file, $purpose, string $contentType = self::contentTypes['uploadFile'][0])
    {
        $returnType = '\AIStats\Sdk\Model\FileResponse';
        $request = $this->uploadFileRequest($file, $purpose, $contentType);

        return $this->client
            ->sendAsync($request, $this->createHttpClientOption())
            ->then(
                function ($response) use ($returnType) {
                    if ($returnType === '\SplFileObject') {
                        $content = $response->getBody(); //stream goes to serializer
                    } else {
                        $content = (string) $response->getBody();
                        if ($returnType !== 'string') {
                            $content = json_decode($content);
                        }
                    }

                    return [
                        ObjectSerializer::deserialize($content, $returnType, []),
                        $response->getStatusCode(),
                        $response->getHeaders()
                    ];
                },
                function ($exception) {
                    $response = $exception->getResponse();
                    $statusCode = $response->getStatusCode();
                    throw new ApiException(
                        sprintf(
                            '[%d] Error connecting to the API (%s)',
                            $statusCode,
                            $exception->getRequest()->getUri()
                        ),
                        $statusCode,
                        $response->getHeaders(),
                        (string) $response->getBody()
                    );
                }
            );
    }

    /**
     * Create request for operation 'uploadFile'
     *
     * @param  \SplFileObject $file (required)
     * @param  string $purpose (required)
     * @param  string $contentType The value for the Content-Type header. Check self::contentTypes['uploadFile'] to see the possible values for this operation
     *
     * @throws \InvalidArgumentException
     * @return \GuzzleHttp\Psr7\Request
     */
    public function uploadFileRequest($file, $purpose, string $contentType = self::contentTypes['uploadFile'][0])
    {

        // verify the required parameter 'file' is set
        if ($file === null || (is_array($file) && count($file) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $file when calling uploadFile'
            );
        }

        // verify the required parameter 'purpose' is set
        if ($purpose === null || (is_array($purpose) && count($purpose) === 0)) {
            throw new \InvalidArgumentException(
                'Missing the required parameter $purpose when calling uploadFile'
            );
        }


        $resourcePath = '/files';
        $formParams = [];
        $queryParams = [];
        $headerParams = [];
        $httpBody = '';
        $multipart = false;




        // form params
        $formDataProcessor = new FormDataProcessor();

        $formData = $formDataProcessor->prepare([
            'file' => $file,
            'purpose' => $purpose,
        ]);

        $formParams = $formDataProcessor->flatten($formData);
        $multipart = $formDataProcessor->has_file;

        $multipart = true;
        $headers = $this->headerSelector->selectHeaders(
            ['application/json', ],
            $contentType,
            $multipart
        );

        // for model (json/xml)
        if (count($formParams) > 0) {
            if ($multipart) {
                $multipartContents = [];
                foreach ($formParams as $formParamName => $formParamValue) {
                    $formParamValueItems = is_array($formParamValue) ? $formParamValue : [$formParamValue];
                    foreach ($formParamValueItems as $formParamValueItem) {
                        $multipartContents[] = [
                            'name' => $formParamName,
                            'contents' => $formParamValueItem
                        ];
                    }
                }
                // for HTTP post (form)
                $httpBody = new MultipartStream($multipartContents);

            } elseif (stripos($headers['Content-Type'], 'application/json') !== false) {
                # if Content-Type contains "application/json", json_encode the form parameters
                $httpBody = \GuzzleHttp\Utils::jsonEncode($formParams);
            } else {
                // for HTTP post (form)
                $httpBody = ObjectSerializer::buildQuery($formParams);
            }
        }

        // this endpoint requires Bearer authentication (access token)
        if (!empty($this->config->getAccessToken())) {
            $headers['Authorization'] = 'Bearer ' . $this->config->getAccessToken();
        }

        $defaultHeaders = [];
        if ($this->config->getUserAgent()) {
            $defaultHeaders['User-Agent'] = $this->config->getUserAgent();
        }

        $headers = array_merge(
            $defaultHeaders,
            $headerParams,
            $headers
        );

        $operationHost = $this->config->getHost();
        $query = ObjectSerializer::buildQuery($queryParams);
        return new Request(
            'POST',
            $operationHost . $resourcePath . ($query ? "?{$query}" : ''),
            $headers,
            $httpBody
        );
    }

    /**
     * Create http client option
     *
     * @throws \RuntimeException on file opening failure
     * @return array of http client options
     */
    protected function createHttpClientOption()
    {
        $options = [];
        if ($this->config->getDebug()) {
            $options[RequestOptions::DEBUG] = fopen($this->config->getDebugFile(), 'a');
            if (!$options[RequestOptions::DEBUG]) {
                throw new \RuntimeException('Failed to open the debug file: ' . $this->config->getDebugFile());
            }
        }

        if ($this->config->getCertFile()) {
            $options[RequestOptions::CERT] = $this->config->getCertFile();
        }

        if ($this->config->getKeyFile()) {
            $options[RequestOptions::SSL_KEY] = $this->config->getKeyFile();
        }

        return $options;
    }

    private function handleResponseWithDataType(
        string $dataType,
        RequestInterface $request,
        ResponseInterface $response
    ): array {
        if ($dataType === '\SplFileObject') {
            $content = $response->getBody(); //stream goes to serializer
        } else {
            $content = (string) $response->getBody();
            if ($dataType !== 'string') {
                try {
                    $content = json_decode($content, false, 512, JSON_THROW_ON_ERROR);
                } catch (\JsonException $exception) {
                    throw new ApiException(
                        sprintf(
                            'Error JSON decoding server response (%s)',
                            $request->getUri()
                        ),
                        $response->getStatusCode(),
                        $response->getHeaders(),
                        $content
                    );
                }
            }
        }

        return [
            ObjectSerializer::deserialize($content, $dataType, []),
            $response->getStatusCode(),
            $response->getHeaders()
        ];
    }

    private function responseWithinRangeCode(
        string $rangeCode,
        int $statusCode
    ): bool {
        $left = (int) ($rangeCode[0].'00');
        $right = (int) ($rangeCode[0].'99');

        return $statusCode >= $left && $statusCode <= $right;
    }
}
