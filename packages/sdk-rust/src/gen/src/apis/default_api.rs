/*
 * AI Stats Gateway API
 *
 * A gateway API for accessing various AI models with OpenAI-compatible endpoints.
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use reqwest;
use serde::{Deserialize, Serialize, de::Error as _};
use crate::{apis::ResponseContent, models};
use super::{Error, configuration, ContentType};


/// struct for typed errors of method [`create_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_chat_completion`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateChatCompletionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_embedding`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateEmbeddingError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_image`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateImageError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_image_edit`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateImageEditError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_moderation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateModerationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_response`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateResponseError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_speech`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateSpeechError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_transcription`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTranscriptionError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_translation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateTranslationError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`create_video`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum CreateVideoError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_analytics`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetAnalyticsError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`get_generation`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum GetGenerationError {
    Status401(models::GetGeneration401Response),
    Status404(models::GetGeneration404Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`healthz`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum HealthzError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_files`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListFilesError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`list_models`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum ListModelsError {
    Status500(models::ListModels500Response),
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_batch`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveBatchError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`retrieve_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RetrieveFileError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`root`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum RootError {
    UnknownValue(serde_json::Value),
}

/// struct for typed errors of method [`upload_file`]
#[derive(Debug, Clone, Serialize, Deserialize)]
#[serde(untagged)]
pub enum UploadFileError {
    UnknownValue(serde_json::Value),
}


/// Creates a batch of API requests.
pub async fn create_batch(configuration: &configuration::Configuration, batch_request: models::BatchRequest) -> Result<models::BatchResponse, Error<CreateBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_batch_request = batch_request;

    let uri_str = format!("{}/batches", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_batch_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BatchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BatchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a completion for the chat message.
pub async fn create_chat_completion(configuration: &configuration::Configuration, chat_completions_request: models::ChatCompletionsRequest) -> Result<models::ChatCompletionsResponse, Error<CreateChatCompletionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_chat_completions_request = chat_completions_request;

    let uri_str = format!("{}/chat/completions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_chat_completions_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ChatCompletionsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ChatCompletionsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateChatCompletionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an embedding vector representing the input text.
pub async fn create_embedding(configuration: &configuration::Configuration, embeddings_request: models::EmbeddingsRequest) -> Result<models::EmbeddingsResponse, Error<CreateEmbeddingError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_embeddings_request = embeddings_request;

    let uri_str = format!("{}/embeddings", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_embeddings_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::EmbeddingsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::EmbeddingsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateEmbeddingError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an image given a prompt.
pub async fn create_image(configuration: &configuration::Configuration, images_generation_request: models::ImagesGenerationRequest) -> Result<models::ImagesGenerationResponse, Error<CreateImageError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_images_generation_request = images_generation_request;

    let uri_str = format!("{}/images/generations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_images_generation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ImagesGenerationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ImagesGenerationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateImageError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates an edited or extended image given an original image and a prompt.
pub async fn create_image_edit(configuration: &configuration::Configuration, model: &str, image: &str, prompt: &str, mask: Option<&str>, size: Option<&str>, n: Option<i32>, user: Option<&str>, meta: Option<bool>, usage: Option<bool>) -> Result<models::ImagesEditResponse, Error<CreateImageEditError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_model = model;
    let p_form_image = image;
    let p_form_prompt = prompt;
    let p_form_mask = mask;
    let p_form_size = size;
    let p_form_n = n;
    let p_form_user = user;
    let p_form_meta = meta;
    let p_form_usage = usage;

    let uri_str = format!("{}/images/edits", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    multipart_form = multipart_form.text("model", p_form_model.to_string());
    multipart_form = multipart_form.text("image", p_form_image.to_string());
    if let Some(param_value) = p_form_mask {
        multipart_form = multipart_form.text("mask", param_value.to_string());
    }
    multipart_form = multipart_form.text("prompt", p_form_prompt.to_string());
    if let Some(param_value) = p_form_size {
        multipart_form = multipart_form.text("size", param_value.to_string());
    }
    if let Some(param_value) = p_form_n {
        multipart_form = multipart_form.text("n", param_value.to_string());
    }
    if let Some(param_value) = p_form_user {
        multipart_form = multipart_form.text("user", param_value.to_string());
    }
    if let Some(param_value) = p_form_meta {
        multipart_form = multipart_form.text("meta", param_value.to_string());
    }
    if let Some(param_value) = p_form_usage {
        multipart_form = multipart_form.text("usage", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ImagesEditResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ImagesEditResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateImageEditError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Classifies if text violates OpenAI's usage policies.
pub async fn create_moderation(configuration: &configuration::Configuration, moderations_request: models::ModerationsRequest) -> Result<models::ModerationsResponse, Error<CreateModerationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_moderations_request = moderations_request;

    let uri_str = format!("{}/moderations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_moderations_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ModerationsResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ModerationsResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateModerationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a response using the Responses API.
pub async fn create_response(configuration: &configuration::Configuration, responses_request: models::ResponsesRequest) -> Result<models::ResponsesResponse, Error<CreateResponseError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_responses_request = responses_request;

    let uri_str = format!("{}/responses", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_responses_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ResponsesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ResponsesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateResponseError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Generates audio from the input text.
pub async fn create_speech(configuration: &configuration::Configuration, audio_speech_request: models::AudioSpeechRequest) -> Result<reqwest::Response, Error<CreateSpeechError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_audio_speech_request = audio_speech_request;

    let uri_str = format!("{}/audio/speech", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_audio_speech_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();

    if !status.is_client_error() && !status.is_server_error() {
        Ok(resp)
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateSpeechError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Transcribes audio into the input language.
pub async fn create_transcription(configuration: &configuration::Configuration, model: &str, audio_url: Option<&str>, audio_b64: Option<&str>, language: Option<&str>) -> Result<models::AudioTranscriptionResponse, Error<CreateTranscriptionError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_model = model;
    let p_form_audio_url = audio_url;
    let p_form_audio_b64 = audio_b64;
    let p_form_language = language;

    let uri_str = format!("{}/audio/transcriptions", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    multipart_form = multipart_form.text("model", p_form_model.to_string());
    if let Some(param_value) = p_form_audio_url {
        multipart_form = multipart_form.text("audio_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_audio_b64 {
        multipart_form = multipart_form.text("audio_b64", param_value.to_string());
    }
    if let Some(param_value) = p_form_language {
        multipart_form = multipart_form.text("language", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudioTranscriptionResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudioTranscriptionResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTranscriptionError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Translates audio into English.
pub async fn create_translation(configuration: &configuration::Configuration, model: &str, audio_url: Option<&str>, audio_b64: Option<&str>, language: Option<&str>, prompt: Option<&str>, temperature: Option<f64>) -> Result<models::AudioTranslationResponse, Error<CreateTranslationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_model = model;
    let p_form_audio_url = audio_url;
    let p_form_audio_b64 = audio_b64;
    let p_form_language = language;
    let p_form_prompt = prompt;
    let p_form_temperature = temperature;

    let uri_str = format!("{}/audio/translations", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    multipart_form = multipart_form.text("model", p_form_model.to_string());
    if let Some(param_value) = p_form_audio_url {
        multipart_form = multipart_form.text("audio_url", param_value.to_string());
    }
    if let Some(param_value) = p_form_audio_b64 {
        multipart_form = multipart_form.text("audio_b64", param_value.to_string());
    }
    if let Some(param_value) = p_form_language {
        multipart_form = multipart_form.text("language", param_value.to_string());
    }
    if let Some(param_value) = p_form_prompt {
        multipart_form = multipart_form.text("prompt", param_value.to_string());
    }
    if let Some(param_value) = p_form_temperature {
        multipart_form = multipart_form.text("temperature", param_value.to_string());
    }
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::AudioTranslationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::AudioTranslationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateTranslationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Creates a video from a prompt.
pub async fn create_video(configuration: &configuration::Configuration, video_generation_request: models::VideoGenerationRequest) -> Result<models::VideoGenerationResponse, Error<CreateVideoError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_video_generation_request = video_generation_request;

    let uri_str = format!("{}/videos", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_video_generation_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::VideoGenerationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::VideoGenerationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<CreateVideoError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns aggregated analytics data.
pub async fn get_analytics(configuration: &configuration::Configuration, get_analytics_request: models::GetAnalyticsRequest) -> Result<models::GetAnalytics200Response, Error<GetAnalyticsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_body_get_analytics_request = get_analytics_request;

    let uri_str = format!("{}/analytics", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    req_builder = req_builder.json(&p_body_get_analytics_request);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GetAnalytics200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GetAnalytics200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetAnalyticsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieve a specific generation by ID.
pub async fn get_generation(configuration: &configuration::Configuration, id: &str) -> Result<models::GenerationResponse, Error<GetGenerationError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_id = id;

    let uri_str = format!("{}/generation", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    req_builder = req_builder.query(&[("id", &p_query_id.to_string())]);
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::GenerationResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::GenerationResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<GetGenerationError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns the health status of the API.
pub async fn healthz(configuration: &configuration::Configuration, ) -> Result<models::Healthz200Response, Error<HealthzError>> {

    let uri_str = format!("{}/healthz", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Healthz200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Healthz200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<HealthzError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of files that belong to the user's organization.
pub async fn list_files(configuration: &configuration::Configuration, ) -> Result<models::ListFilesResponse, Error<ListFilesError>> {

    let uri_str = format!("{}/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListFilesResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListFilesResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListFilesError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a list of available models.
pub async fn list_models(configuration: &configuration::Configuration, endpoints: Option<Vec<String>>, organisation: Option<models::ListModelsOrganisationParameter>, input_types: Option<Vec<String>>, output_types: Option<Vec<String>>, params: Option<Vec<String>>, limit: Option<i32>, offset: Option<i32>) -> Result<models::ListModels200Response, Error<ListModelsError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_query_endpoints = endpoints;
    let p_query_organisation = organisation;
    let p_query_input_types = input_types;
    let p_query_output_types = output_types;
    let p_query_params = params;
    let p_query_limit = limit;
    let p_query_offset = offset;

    let uri_str = format!("{}/models", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref param_value) = p_query_endpoints {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("endpoints".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("endpoints", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_organisation {
        req_builder = req_builder.query(&[("organisation", &serde_json::to_string(param_value)?)]);
    }
    if let Some(ref param_value) = p_query_input_types {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("input_types".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("input_types", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_output_types {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("output_types".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("output_types", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_params {
        req_builder = match "multi" {
            "multi" => req_builder.query(&param_value.into_iter().map(|p| ("params".to_owned(), p.to_string())).collect::<Vec<(std::string::String, std::string::String)>>()),
            _ => req_builder.query(&[("params", &param_value.into_iter().map(|p| p.to_string()).collect::<Vec<String>>().join(",").to_string())]),
        };
    }
    if let Some(ref param_value) = p_query_limit {
        req_builder = req_builder.query(&[("limit", &param_value.to_string())]);
    }
    if let Some(ref param_value) = p_query_offset {
        req_builder = req_builder.query(&[("offset", &param_value.to_string())]);
    }
    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::ListModels200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::ListModels200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<ListModelsError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Retrieves a batch.
pub async fn retrieve_batch(configuration: &configuration::Configuration, batch_id: &str) -> Result<models::BatchResponse, Error<RetrieveBatchError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_batch_id = batch_id;

    let uri_str = format!("{}/batches/{batch_id}", configuration.base_path, batch_id=crate::apis::urlencode(p_path_batch_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::BatchResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::BatchResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveBatchError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns information about a specific file.
pub async fn retrieve_file(configuration: &configuration::Configuration, file_id: &str) -> Result<models::FileResponse, Error<RetrieveFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_path_file_id = file_id;

    let uri_str = format!("{}/files/{file_id}", configuration.base_path, file_id=crate::apis::urlencode(p_path_file_id));
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RetrieveFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Returns a welcome message.
pub async fn root(configuration: &configuration::Configuration, ) -> Result<models::Root200Response, Error<RootError>> {

    let uri_str = format!("{}/", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::GET, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::Root200Response`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::Root200Response`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<RootError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

/// Upload a file that can be used across various endpoints.
pub async fn upload_file(configuration: &configuration::Configuration, file: std::path::PathBuf, purpose: &str) -> Result<models::FileResponse, Error<UploadFileError>> {
    // add a prefix to parameters to efficiently prevent name collisions
    let p_form_file = file;
    let p_form_purpose = purpose;

    let uri_str = format!("{}/files", configuration.base_path);
    let mut req_builder = configuration.client.request(reqwest::Method::POST, &uri_str);

    if let Some(ref user_agent) = configuration.user_agent {
        req_builder = req_builder.header(reqwest::header::USER_AGENT, user_agent.clone());
    }
    if let Some(ref token) = configuration.bearer_access_token {
        req_builder = req_builder.bearer_auth(token.to_owned());
    };
    let mut multipart_form = reqwest::multipart::Form::new();
    // TODO: support file upload for 'file' parameter
    multipart_form = multipart_form.text("purpose", p_form_purpose.to_string());
    req_builder = req_builder.multipart(multipart_form);

    let req = req_builder.build()?;
    let resp = configuration.client.execute(req).await?;

    let status = resp.status();
    let content_type = resp
        .headers()
        .get("content-type")
        .and_then(|v| v.to_str().ok())
        .unwrap_or("application/octet-stream");
    let content_type = super::ContentType::from(content_type);

    if !status.is_client_error() && !status.is_server_error() {
        let content = resp.text().await?;
        match content_type {
            ContentType::Json => serde_json::from_str(&content).map_err(Error::from),
            ContentType::Text => return Err(Error::from(serde_json::Error::custom("Received `text/plain` content type response that cannot be converted to `models::FileResponse`"))),
            ContentType::Unsupported(unknown_type) => return Err(Error::from(serde_json::Error::custom(format!("Received `{unknown_type}` content type response that cannot be converted to `models::FileResponse`")))),
        }
    } else {
        let content = resp.text().await?;
        let entity: Option<UploadFileError> = serde_json::from_str(&content).ok();
        Err(Error::ResponseError(ResponseContent { status, content, entity }))
    }
}

