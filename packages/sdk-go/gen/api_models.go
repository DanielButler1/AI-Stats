/*
AI Stats Gateway API

Programmatic access to the AI Stats AI Gateway. All endpoints forward requests to the best available provider for the specified model, and return normalised responses with clear structured metadata.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ai_stats_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModelsAPIService ModelsAPI service
type ModelsAPIService service

type ApiModelsGetRequest struct {
	ctx context.Context
	ApiService *ModelsAPIService
	endpoints *ModelsGetEndpointsParameter
	organisation *ModelsGetOrganisationParameter
	inputTypes *ModelsGetInputTypesParameter
	outputTypes *ModelsGetInputTypesParameter
	params *ModelsGetInputTypesParameter
	limit *int32
	offset *int32
}

// Only return models that support at least one of the specified gateway endpoints.
func (r ApiModelsGetRequest) Endpoints(endpoints ModelsGetEndpointsParameter) ApiModelsGetRequest {
	r.endpoints = &endpoints
	return r
}

// Restrict results to models associated with one or more organisation identifiers.
func (r ApiModelsGetRequest) Organisation(organisation ModelsGetOrganisationParameter) ApiModelsGetRequest {
	r.organisation = &organisation
	return r
}

// Only return models that advertise support for at least one of the requested input content types.
func (r ApiModelsGetRequest) InputTypes(inputTypes ModelsGetInputTypesParameter) ApiModelsGetRequest {
	r.inputTypes = &inputTypes
	return r
}

// Only return models that advertise support for at least one of the requested output content types.
func (r ApiModelsGetRequest) OutputTypes(outputTypes ModelsGetInputTypesParameter) ApiModelsGetRequest {
	r.outputTypes = &outputTypes
	return r
}

// Only return models that support at least one of the specified parameters.
func (r ApiModelsGetRequest) Params(params ModelsGetInputTypesParameter) ApiModelsGetRequest {
	r.params = &params
	return r
}

// Maximum number of models to return (default 50).
func (r ApiModelsGetRequest) Limit(limit int32) ApiModelsGetRequest {
	r.limit = &limit
	return r
}

// Number of models to skip before starting the page.
func (r ApiModelsGetRequest) Offset(offset int32) ApiModelsGetRequest {
	r.offset = &offset
	return r
}

func (r ApiModelsGetRequest) Execute() (*ModelListResponse, *http.Response, error) {
	return r.ApiService.ModelsGetExecute(r)
}

/*
ModelsGet List all gateway models

Returns a paginated catalogue of models with provider mappings, aliases, and endpoint support. Results are sorted by release date in descending order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModelsGetRequest
*/
func (a *ModelsAPIService) ModelsGet(ctx context.Context) ApiModelsGetRequest {
	return ApiModelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelListResponse
func (a *ModelsAPIService) ModelsGetExecute(r ApiModelsGetRequest) (*ModelListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModelsAPIService.ModelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/models"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.endpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "endpoints", r.endpoints, "form", "")
	}
	if r.organisation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organisation", r.organisation, "form", "")
	}
	if r.inputTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "input_types", r.inputTypes, "form", "")
	}
	if r.outputTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_types", r.outputTypes, "form", "")
	}
	if r.params != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "params", r.params, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
