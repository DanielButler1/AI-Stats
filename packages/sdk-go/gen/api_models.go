/*
AI Stats Gateway API

Programmatic access to the AI Stats AI Gateway. All endpoints forward requests to the best available provider for the specified model, and return normalised responses with clear structured metadata.

API version: 0.1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package ai_stats_sdk

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
)


// ModelsAPIService ModelsAPI service
type ModelsAPIService service

type ApiModelsGetRequest struct {
	ctx context.Context
	ApiService *ModelsAPIService
	provider *ModelsGetProviderParameter
	limit *int32
	offset *int32
	organisation *ModelsGetOrganisationParameter
	includeEndpoints *ModelsGetIncludeEndpointsParameter
	excludeEndpoints *ModelsGetIncludeEndpointsParameter
	inputTypes *ModelsGetProviderParameter
	outputTypes *ModelsGetProviderParameter
	includeRumoured *bool
	includeDeprecated *bool
	includeRetired *bool
}

// Filter results to models served by one or more provider identifiers.
func (r ApiModelsGetRequest) Provider(provider ModelsGetProviderParameter) ApiModelsGetRequest {
	r.provider = &provider
	return r
}

// Maximum number of models to return (default 50).
func (r ApiModelsGetRequest) Limit(limit int32) ApiModelsGetRequest {
	r.limit = &limit
	return r
}

// Number of models to skip before starting the page.
func (r ApiModelsGetRequest) Offset(offset int32) ApiModelsGetRequest {
	r.offset = &offset
	return r
}

// Restrict results to models associated with one or more organisation identifiers.
func (r ApiModelsGetRequest) Organisation(organisation ModelsGetOrganisationParameter) ApiModelsGetRequest {
	r.organisation = &organisation
	return r
}

// Only return models that support at least one of the specified gateway endpoints.
func (r ApiModelsGetRequest) IncludeEndpoints(includeEndpoints ModelsGetIncludeEndpointsParameter) ApiModelsGetRequest {
	r.includeEndpoints = &includeEndpoints
	return r
}

// Exclude models that support any of the specified gateway endpoints.
func (r ApiModelsGetRequest) ExcludeEndpoints(excludeEndpoints ModelsGetIncludeEndpointsParameter) ApiModelsGetRequest {
	r.excludeEndpoints = &excludeEndpoints
	return r
}

// Only return models that advertise support for at least one of the requested input content types.
func (r ApiModelsGetRequest) InputTypes(inputTypes ModelsGetProviderParameter) ApiModelsGetRequest {
	r.inputTypes = &inputTypes
	return r
}

// Only return models that advertise support for at least one of the requested output content types.
func (r ApiModelsGetRequest) OutputTypes(outputTypes ModelsGetProviderParameter) ApiModelsGetRequest {
	r.outputTypes = &outputTypes
	return r
}

// Whether to include models marked as rumoured in the response (default true).
func (r ApiModelsGetRequest) IncludeRumoured(includeRumoured bool) ApiModelsGetRequest {
	r.includeRumoured = &includeRumoured
	return r
}

// Whether to include models marked as deprecated in the response (default true).
func (r ApiModelsGetRequest) IncludeDeprecated(includeDeprecated bool) ApiModelsGetRequest {
	r.includeDeprecated = &includeDeprecated
	return r
}

// Whether to include models marked as retired in the response (default true).
func (r ApiModelsGetRequest) IncludeRetired(includeRetired bool) ApiModelsGetRequest {
	r.includeRetired = &includeRetired
	return r
}

func (r ApiModelsGetRequest) Execute() (*ModelListResponse, *http.Response, error) {
	return r.ApiService.ModelsGetExecute(r)
}

/*
ModelsGet List all gateway models

Returns a paginated catalogue of models with provider mappings, aliases, and endpoint support. Results are sorted by release date (falling back to announcement date) in descending order.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiModelsGetRequest
*/
func (a *ModelsAPIService) ModelsGet(ctx context.Context) ApiModelsGetRequest {
	return ApiModelsGetRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ModelListResponse
func (a *ModelsAPIService) ModelsGetExecute(r ApiModelsGetRequest) (*ModelListResponse, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ModelListResponse
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ModelsAPIService.ModelsGet")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/models"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.provider != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "provider", r.provider, "form", "")
	}
	if r.limit != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "limit", r.limit, "form", "")
	}
	if r.offset != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "offset", r.offset, "form", "")
	}
	if r.organisation != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "organisation", r.organisation, "form", "")
	}
	if r.includeEndpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_endpoints", r.includeEndpoints, "form", "")
	}
	if r.excludeEndpoints != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "exclude_endpoints", r.excludeEndpoints, "form", "")
	}
	if r.inputTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "input_types", r.inputTypes, "form", "")
	}
	if r.outputTypes != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "output_types", r.outputTypes, "form", "")
	}
	if r.includeRumoured != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_rumoured", r.includeRumoured, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_rumoured", defaultValue, "form", "")
        r.includeRumoured = &defaultValue
	}
	if r.includeDeprecated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_deprecated", r.includeDeprecated, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_deprecated", defaultValue, "form", "")
        r.includeDeprecated = &defaultValue
	}
	if r.includeRetired != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "include_retired", r.includeRetired, "form", "")
	} else {
        var defaultValue bool = true
        parameterAddToHeaderOrQuery(localVarQueryParams, "include_retired", defaultValue, "form", "")
        r.includeRetired = &defaultValue
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 401 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 429 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 500 {
			var v GatewayError
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
					newErr.error = formatErrorMessage(localVarHTTPResponse.Status, &v)
					newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
